ex 9:
Cart implements Media
Store implements Media
Aims implements Cart
Aims implements Store
Compact Disc implements Track 
Media implements MediaComparatorByTitleCost, MediaComparatorByCostTitle;

ex 11:
Each media in the list executes a different toString method because it is dynamic binding which means the called method depends on the objects and not depends on the referrence to the object. In this case, each media refer to different objects of 3 different classes so they have different toString method.

ex 10: 
If instance passed in method "equals" is not a Media obj, we will check the instance by method "instanceof" and print out message that if that instance is a Media obj or not.
Q12: 
- What class should implement the Comparable interface?
	Ans : Implement Comparable interface in Media class in order to sorting media .
- In those classes, how should you implement the compareTo() method be to reflect the ordering that we want?
	Ans : public class Media implements Comparable<Media>{}
+ Example: compareTo method for sorting cost-title:
@Override
public int compareTo(Media o){
    return Comparator.comparing(Media::title)
              .thenComparingInt(Media::getCost);
}
- Can we have two ordering rules of the item (by title then cost and by cost then title) if we use this Comparable interface approach?
Ans : Yes since class Media can override compareTo() method and then we can compared the 2 obj by overriding thenComparing() method
- Suppose the DVDs has a different ordering rule from the other media types, that is by title, then decreasing length, then cost. How would you modify your code to allow this?
Ans :
@Override
public int compareTo(Media o){
    return Comparator.comparing(Media::title)
              .thenComparingInt(Media::getLength)
              .thenComparingInt(Media::getCost);
}